<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>

    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
          integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="css/style.css">

    <!-- D3/jquery/bootstrap -->
    <script src="https://d3js.org/d3.v5.min.js"
            integrity="sha384-M06Cb6r/Yrkprjr7ngOrJlzgekrkkdmGZDES/SUnkUpUol0/qjsaQWQfLzq0mcfg"
            crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
            integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
            crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
            crossorigin="anonymous"></script>

    <!-- Common Functionalities Shared Among Pages -->
    <script src="js/common.js"></script>
    <script src="js/lib/greadability.js"></script>
    <script src="js/lib/GraphQuality.js"></script>

    <!-- JavaScript for UntangleJS -->
    <script src="untangleJS/lib/DisjointSet.js"></script>
    <script src="untangleJS/lib/MaximalSpanningTree.js"></script>
    <script src="untangleJS/lib/NodeDegree.js"></script>
    <script src="untangleJS/lib/JaccardWeights.js"></script>
    <script src="untangleJS/lib/PriorityQueue.js"></script>
    <script src="untangleJS/SpanningTreeLayout.js"></script>
    <script src="untangleJS/SpanningTreeCycles.js"></script>
    <script src="untangleJS/LoopForce.js"></script>
    <script src="untangleJS/PH0D.js"></script>
    <script src="untangleJS/PH1D.js"></script>
    <script src="untangleJS/GraphDraw.js"></script>

    <title>Persistent Homology Makes Force-Directed Layouts Better</title>

</head>
<body>

    <script>insert_navbar("internal_generate_figures.html");</script>

    <div class="page">

        <h3>This page will automatically generate data that hasn't been created yet.</h3>
        <h3>Place the files generated by this page into the figures directory and run the script that will convert SVGs to PNGs.</h3>
        <div style="display: flex;">
                        <div style="width: fit-content">
                <div style="width: fit-content">
                    <svg id="barcode" width=150 height=600 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>
                </div>
            </div>
            <div style="width: fit-content">
                <div style="width: fit-content; padding-top: 20px">
                    <svg id="barcode1d" width=150 height=600 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>
                </div>
            </div>
            <div>
                <svg id="graph" width=800 height=625 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>
            </div>
            <div style="margin: 20pt; text-align: center">

                <h3>Status</h3>
                <ul id="status_ul" style="margin: auto; text-align: left">
                </ul>
            </div>
        </div>
    </div>
</body>

<script>

let graph = null
let graphDraw = null
let stlayout = null
let data_stats = []
let ph0d = null
let ph1d = null


function change_dataset(){

    let start_time = performance.now()
    d3.json( current_exp.dataset )
        .then(_graph => {
            let end_time = performance.now()

            graph = _graph;
            graph.file = current_exp.dataset
            graph.timing = {}
            graph.timing.download = {name:"Download/Parse Time", value: (end_time - start_time)}

            // For graphs without weights
            start_time = performance.now()
            let weightRange = d3.extent( graph.links, l=> ('value' in l) ? l.value : 1 )
            if( weightRange[1] - weightRange[0] === 0)
                calculate_jaccard_weights(graph)
            calculate_node_degree(graph)
            end_time = performance.now()
            graph.timing.jaccard = {name:"Degree & (Jaccard) Weight Calculation", value: (end_time - start_time)}

            start_time = performance.now()
            stlayout = SpanningTreeLayout(graph)
            end_time = performance.now()
            graph.timing.spanning_tree = {name:"Spanning Tree Calculation", value: (end_time - start_time)}

            if (ph0d){ ph0d.remove(); ph0d = null; }
            if( current_exp.needPH0D ) {
                start_time = performance.now()
                ph0d = PersistentHomology0D("#barcode", graph, stlayout.spanning_tree())
                end_time = performance.now()
                graph.timing.ph0d = {name: "PH0D Calculation", value: (end_time - start_time)}
            }

            if (ph1d){ ph1d.remove(); ph1d = null; }
            if( current_exp.needPH1D ) {
                start_time = performance.now()
                ph1d = PersistentHomology1D("#barcode1d", graph, stlayout.spanning_tree())
                end_time = performance.now()
                graph.timing.ph1d = {name: "PH1D Calculation", value: (end_time - start_time)}
            }

            reset_graph()
        });
}



let current_exp = null
let prior_exp = null

function skip_experiment(){
    let newP = document.createElement('li')
    newP.innerHTML = "Skipping " + current_exp.exp_name
    document.getElementById('status_ul').prepend(newP)
    current_exp = null
    next_experiment()
}

function run_experiment(){
    let newP = document.createElement('li')
        newP.innerHTML = "Starting " + current_exp.exp_name
    document.getElementById('status_ul').prepend(newP)
    if (prior_exp == null || current_exp.dataset !== prior_exp.dataset) {
        //document.getElementById('dataset').value = dataset.indexOf(current_exp.dataset)
        change_dataset()
    } else {
        reset_graph()
    }
}

function next_experiment(){
    if( experiments.length > 0 ) {
        current_exp = experiments.shift()
        d3.csv('figures/'+ current_exp.exp_name + ".csv").then( (data)=>{
            if( data.length === current_exp.recordsExpected )
                skip_experiment()
            else
                run_experiment()
        }).catch( (err)=>{
            run_experiment()
        })
    }
    else{
        let newP = document.createElement('li')
            newP.innerHTML = "Operation Complete"
        document.getElementById('status_ul').prepend(newP)
        graphDraw.stopSimulation()
        d3.select("#graph").selectAll("*").remove();
        if (ph0d){ ph0d.remove(); ph0d = null; }
        if (ph1d){ ph1d.remove(); ph1d = null; }
    }
}


function reset_graph( ){
    d3.select("#graph").selectAll("*").remove();

    let layout_method = current_exp.layout

    if( layout_method === 'neato' || layout_method === 'sfdp' || layout_method === 'fdp'){
        graph.nodes.forEach(n=>{
            n.fx = n.x
            n.fy = n.y
        })
    }
    else{
        // Clear any existing node positions
        graph.nodes.forEach(n=>{
          delete n.x
          delete n.y
        })

        // Initialize Layout
        let start_time = performance.now()
        if( layout_method === 'radial_spaced_layout') stlayout.radial_spaced_layout([5,795],[5,595])
        if( layout_method === 'radial_layout') stlayout.radial_layout([5,795],[5,595])
        if( layout_method === 'layered_spaced_layout') stlayout.layered_spaced_layout([5,795],[5,595])
        if( layout_method === 'layered_layout') stlayout.layered_layout([5,795],[5,595])
        let end_time = performance.now()
        graph.timing.layout_time = ({name:"layout time", method: layout_method, value: (end_time - start_time)})
    }


    start_time = performance.now()
    let cur_ds = current_exp.dataset
    cur_ds = cur_ds.substring(5,cur_ds.length-5)

    let graph_quality = GraphQuality(graph, current_exp.exp_name )
    end_time = performance.now()
    graph.timing.quality = {name:"Graph Quality Time", value: (end_time - start_time)}

    // Draw Graph
    start_time = performance.now()
    let iteration = 1
    graphDraw = GraphDraw(graph).set_tick_callback( ()=>{
        if( current_exp.calculate_quality(iteration) ) {
            graph_quality.update(iteration)
        }
        current_exp.actions.forEach( act => {
            if( iteration === act.iteration ) act.action()
        })
        iteration++
    })

    update_graph_draw_colors(graphDraw,
                             current_exp.color === 'color_by_group',
                             current_exp.color === 'color_by_degree',
                             current_exp.color === 'color_by_degree_ranked')

    if( ph0d ) ph0d.set_graph_draw(graphDraw)
    if( ph1d ) ph1d.set_graph_draw(graphDraw)

    end_time = performance.now()
    graph.timing.fdl_init = {name:"fdl setup time", value: (end_time - start_time)}

}




function initial_layout_exp(dataset, layout, large_data=false) {
    let save_iterations = [1,5,10,25,50,300]
    let short_name = dataset.substring(5,dataset.length-5)
    if( large_data ) short_name = dataset.substring(11,dataset.length-5)
    let experiment_name = "init_layout_" + short_name + "_" + layout
    let rexp = large_data ? save_iterations.length : 300
    return {
        dataset: dataset,
        layout: layout,
        exp_name: experiment_name,
        needPH0D: false,
        needPH1D: false,
        recordsExpected: rexp,
        calculate_quality: (iterNum) => {
            if( !large_data ) return true
            return ( large_data && save_iterations.includes(iterNum))
        },
        color: dataset_colors[dataset],
        actions: [
            { iteration: 1,
                action: () => { graphDraw.fit_graph(); downloadSVG("graph", experiment_name + "_initial.svg") } },
            { iteration: 5,
                action: () => { if (large_data) { graphDraw.fit_graph(); downloadSVG("graph", experiment_name + "_5.svg") } } },
            { iteration: 10,
                action: () => { if (large_data) { graphDraw.fit_graph(); downloadSVG("graph", experiment_name + "_10.svg") } } },
            { iteration: 25,
                action: () => { if (large_data) { graphDraw.fit_graph(); downloadSVG("graph", experiment_name + "_25.svg") } } },
            { iteration: 50,
                action: () => { if (large_data) { graphDraw.fit_graph(); downloadSVG("graph", experiment_name + "_50.svg") } } },
            { iteration: 150,
                action: () => { /*graphDraw.restartSimulation()*/ } },
            { iteration: 300,
                action: () => {
                    graphDraw.stopSimulation()
                    graphDraw.fit_graph()
                    downloadSVG("graph", experiment_name + "_final.svg")
                    console.log(dataset + " (" + layout + ") done, waiting on server...")
                    next_experiment()
                }
            }
        ]
    }
}

function force_h0_exp(dataset){
    let short_name = dataset.substring(5,dataset.length-5)
    let experiment_name = "h0_" + short_name

    return { dataset: dataset,
             layout: 'random',
             needPH0D: true,
             needPH1D: false,
             exp_name: experiment_name,
             recordsExpected: 1,
             calculate_quality: (iterNum) => { return iterNum === 400 },
             color: dataset_colors[dataset],
             actions: [
                        { iteration:150, action: ()=> {
                            graphDraw.fit_graph()
                            ph0d.update_threshold(95)
                        } },
                        { iteration:400, action: ()=> {
                            graphDraw.stopSimulation()
                            graphDraw.fit_graph()
                            downloadSVG("graph", experiment_name + '.svg')
                            next_experiment()
                        } } ]
            }
}


function highlight_loop_exp(dataset,layout, color, index){
    let short_name = dataset.substring(5,dataset.length-5)
    let experiment_name = "h1_" + short_name + "_" + index + "_loop"

    return { dataset: dataset,
             layout: layout,
             color: dataset_colors[dataset],
             needPH0D: true,
             needPH1D: true,
             recordsExpected: 1,
             exp_name: experiment_name,
             calculate_quality: (iterNum) => { return iterNum === 150 },
             outfile: 'h1/' + short_name + '_graph_' + index + '.svg',
             actions: [ { iteration:150,
                           action: ()=> {
                                graphDraw.stopSimulation()
                                graphDraw.fit_graph()
                                ph1d.highlight_loop(index);
                                downloadSVG("graph", experiment_name + '_graph.svg')
                                downloadSVG("barcode1d", experiment_name + '_barcode.svg')
                                ph1d.unhighlight_loop(index)
                                next_experiment()
                        } } ]
            }
}

function force_h1_exp(dataset,layout, color, index, force_loop, force_loop_amnt){
    let short_name = dataset.substring(5,dataset.length-5)
    let experiment_name = "h1_" + short_name + "_" + index + "_force"

    return { dataset: dataset,
             layout: layout,
             color: dataset_colors[dataset],
             needPH0D: true,
             needPH1D: true,
             recordsExpected: 1,
             exp_name: experiment_name,
             calculate_quality: (iterNum) => { return iterNum === 600 },
             actions: [ { iteration:150, action: ()=> {
                            graphDraw.fit_graph()
                            ph1d.activate_loop( force_loop, force_loop_amnt )
                        } },
                        { iteration:250, action: ()=> {
                            graphDraw.fit_graph()
                            ph1d.activate_loop( force_loop, force_loop_amnt )
                        } },
                        { iteration:350, action: ()=> {
                            graphDraw.fit_graph()
                            graphDraw.restartSimulation()
                        } },
                        { iteration:600, action: ()=> {
                            graphDraw.stopSimulation()
                            graphDraw.fit_graph()
                            ph1d.highlight_loop(index);
                            downloadSVG("graph", experiment_name + '_graph.svg')
                            downloadSVG("barcode1d", experiment_name + '_barcode.svg')
                            ph1d.unhighlight_loop(index)
                            ph1d.deactivate_loops([index])
                            next_experiment()
                        } } ]
            }
}




function other_algo_exp(dataset, layout, large_data = false){
    let short_name = dataset.substring(5,dataset.length-5)
    if( large_data ) short_name = dataset.substring(11,dataset.length-5)
    let experiment_name = "other_" + short_name + "_" + layout

    return { dataset: 'data/'+layout+'/'+short_name+'.json',
             layout: layout,
             color: dataset_colors[dataset],
             needPH0D: false,
             needPH1D: false,
             recordsExpected: 1,
             exp_name: experiment_name,
             calculate_quality: (iterNum) => { return iterNum === 1 },
             actions: [ { iteration:1, action: ()=> {
                            graphDraw.fit_graph()
                            graphDraw.stopSimulation()
                            downloadSVG("graph", experiment_name + '.svg')
                            next_experiment()
                        } },
                        { iteration:10, action: ()=> {
                            graphDraw.fit_graph()
                            downloadSVG("graph", experiment_name + '.svg')
                            next_experiment()
                        } } ]
            }
}



function animate_layout(dataset, layout, large_data=false, stats=false) {
    let save_iterations = [1,5,10,25,50,300]
    let short_name = dataset.substring(5,dataset.length-5)
    if( large_data ) short_name = dataset.substring(11,dataset.length-5)
    let experiment_name = "animate_" + short_name + "_" + layout
    let rexp = 300
    let act = []
    for(let i = 1; i < 300; i++){
      act.push({iteration: i, action: () => { graphDraw.fit_graph(); downloadSVG("graph", experiment_name + "_" + i.toString() + ".svg") }})
    }
    act.push({ iteration: 300,
                action: () => {
                    graphDraw.stopSimulation()
                    graphDraw.fit_graph()
                    downloadSVG("graph", experiment_name + "_300.svg")
                    console.log(dataset + " (" + layout + ") done, waiting on server...")
                    next_experiment()
                }
            })


    return {
        dataset: dataset,
        layout: layout,
        exp_name: experiment_name,
        needPH0D: false,
        needPH1D: false,
        recordsExpected: rexp,
        calculate_quality: (iterNum) => { return stats },
        color: dataset_colors[dataset],
        actions: act
    }
}



let experiments = [initial_layout_exp('data/dummy.json', 'random')]
experiments[0].recordsExpected = -1


dataset.forEach( ds =>{
    layouts.forEach( ltype =>{
        experiments.push(initial_layout_exp(ds, ltype))
    })
})

dataset.forEach( d =>{
    experiments.push(force_h0_exp(d, 'random'))
})






Object.keys(exp_loop).forEach( d =>{
    exp_loop[d].forEach( l => {
        experiments.push(highlight_loop_exp(d, 'random', dataset_colors[d], l))
    })
})

Object.keys(exp_loop).forEach( d =>{
    exp_loop[d].forEach( l => {
        experiments.push(force_h1_exp(d, 'random', dataset_colors[d], l, l ,0.95))
    })
})

large_data.forEach( ds =>{
    layouts.forEach( ltype =>{
        experiments.push(initial_layout_exp(ds, ltype, true))
    })
})

dataset.forEach( ds =>{
    experiments.push(other_algo_exp(ds, 'neato'))
    experiments.push(other_algo_exp(ds, 'fdp'))
    experiments.push(other_algo_exp(ds, 'sfdp'))
})


large_data.forEach( ds =>{
    experiments.push(other_algo_exp(ds, 'neato', true))
    experiments.push(other_algo_exp(ds, 'fdp', true))
    experiments.push(other_algo_exp(ds, 'sfdp', true))
})


large_data.forEach( ds => {
    layouts.forEach(ltype => {
        experiments.push(animate_layout(ds, ltype, true, true))
    })
})

next_experiment()


</script>
</html>
